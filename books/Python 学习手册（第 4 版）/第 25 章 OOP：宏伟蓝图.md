# 第 25 章 OOP：宏伟蓝图

## 为何使用类

类是 Python 的程序组成单元，就像函数和模块一样：类是封装逻辑和数据的另一种方式。

类也定义新的命名空间，在很大程度上就像模块。

和其他程序组成单元相比，类有三个重要的独到之处，使其在建立新对象时更为有用。

- 多重实例：每次调用一个类，就会产生一个有独立命名空间的新对象。

- 通过继承进行定制：类可以建立命名空间的层次结构。

- 运算符重载：通过提供特定的协议方法，类可以定义对象来响应在内置类型上的几种运算。

## 概览 OOP

### 属性继承搜索

找出 attribute 首次出现的地方，先搜索 object，然后是该对象之上的所有类，由下至上，由左至右。
```python
object.attribute
```

**继承搜索树**

每次使用 `object.attribute` 表达式时，Python 会在运行期间去“爬树”，来搜索属性。树中位置较高的类称为超类（superclass），位置较低的类则称为子类（subclass）。超类提供了所有子类共享的行为，但是因为搜索是由下而上，子类可能会在树中较低位置重新定义超类的变量名，从而覆盖超类定义的行为。

### 类和实例

在 Python 对象模型中，类和通过类产生的实例是两种不同的对象类型。

- 类：类是实例工厂。类的属性提供了行为（数据以及函数），所有从类产生的实例都继承该类的属性。
- 实例：代表程序领域中具体的元素。实例属性记录数据，而每个特定对象的数据都不同。

类和模块的另一个差异：内存中特定模块只有一个实例（所以我们得重载模块以取得其新代码），但是，对类而言，只要有需要，制作多少实例都可以。

### 类方法调用

每当我们调用附属于类的函数时，总会隐含着这个类的实例。Python 会把隐含的实例传进方法中的第一个特殊参数，习惯上将其称为 `self`。


### 编写类树

- 每个 `class` 语句会生成一个新的类对象。

- 每次调用类时，就会生成一个新的实例对象。

- 实例自动连接至创建了这些实例的类。

- 类连接至其超类的方式是，将超类列在类头部的括号内。其从左至右的顺序会决定树中的次序。

```python
class C2: ...                      # Make class objects (ovals)
class C3: ...
class C1(C2, C3): ...              # Linked to superclasses

I1 = C1()                          # Make instance objects (rectangles)
I2 = C1()                          # Linked to their classes
```

属性通常是在类内，对传给函数的特殊参数（也就是 `self`），做赋值运算而添加在实例中的。
```python
class C1(C2, C3):
    def __init__(self, who):     # Set name when constructed
        self.name = who          # Self is either I1 or I2

I1 = C1('bob')                   # Sets I1.name to ‘bob’
I2 = C1('mel')                   # Sets I2.name to ‘mel’
print(I1.name)                   # Prints ‘bob’
```

附加在实例上的属性只属于那些实例，但附加在类上的属性则由所有子类及其实例共享。

### OOP 是为了代码重用

类其实就是由函数和变量名所构成的包，很像模块。