[TOC]

# 第 3 章 变量和引用

## 3.1 深入认识变量

### 3.1.1 什么是变量

略

### 3.1.2 变量的命名

略

### 3.1.3 变量的类型

Shell 是一种动态类型语言和弱类型语言，即 Shell 中，变量的数据类型无需显示地声明，变量的数据类型会根据不同的操作有所变化。准确地讲，Shell 中的变量是不分数据类型的，++**统一地按照字符串存储**++。但是根据变量的上下文环境，允许程序执行一些不同的操作，例如字符串的比较和整数的加减等。

执行加法运算
```bash
$ x=123
# 变量 x 加 1
$ let "x += 1"
$ echo "x = ${x}"
x = 124
```

替换字符串
```bash
# 为避免示例之间相互影响，先重置 x 为空
$ unset x
# 替换 x 中的 4 为 abc
$ x=456
$ x=${x/4/abc}
$ echo "x = ${x}"
x = abc56
```

声明变量类型，如果变量没有定义（赋值），则默认为空。
```bash
$ unset x
$ declare -i x
$ echo "x = ${x}"
x =
```

注意：在变量赋值后声明类型，不影响其原来的值。
```bash
$ unset x
$ x=789
$ declare -i x
$ echo "x = ${x}"
x = 789
$ let "x += 1"
$ echo "x = ${x}"
x = 790
```

执行加法运算时，如果遇到变量含有非数字的字符串，Shell 会自动进行数据类型的转换，变量的值将被转换成整数 0。
```bash
$ unset x
$ x=abc123
$ declare -i x
$ echo "x = ${x}"
x = abc123
$ let "x += 1"
$ echo "x = ${x}"
x = 1
```

在空串以及未定义变量的情况下，执行加法运算时，变量的值都会被转换为整数 0。
```bash
$ unset x
$ x=""
$ echo "x = ${x}"
x = 
$ let "x += 1"
$ echo "x = ${x}"
x = 1
```

```bash
$ unset x
$ echo "x = ${x}"
x = 
$ let "x += 1"
$ echo "x = ${x}"
x = 1
```

从上面的例子可以看到，Shell 中的变量非常灵活，可以参与任何运算。实际上，**在 Shell 中，一切变量都是字符串类型的**。

### 3.1.4 变量的定义

在 Shell 中，通常情况下用户可以直接使用变量，无需先进行定义，当用户第一次使用某个变量名时，实际上就同时定义了这个变量，在变量的作用域内，用户都可以使用该变量。

为了更好地控制变量的相关属性，bash 提供了一个名称为 `declare` 的命令来声明变量，该命令的基本语法如下：
```bash
declare attribute variable
```

其中，`attribute` 表示变量的属性，常用的属性有如下：

- `-p`：显示所有变量的值。【注：？】
- `-i`：将变量定义为整数。在之后就可以直接对表达式求值，结果只能是整数。如果求值失败或者不是整数，就设置为 `0`。
- `-r`：将变量声明为只读变量。只读变量不允许修改，++**也不允许删除**++。
- `-a`：将变量声明为数组变量。但这没有必要。所有变量都不必显式定义就可以用做数组。事实上，在某种意义上，所有变量都是数组，因为赋值给没有下标的变量与赋值给下标为 `0` 的数组元素相同。【注：也就是说，如果变量 x 是一个数组，那么`x=5` 和 `x[0]=5` 是一样的，都表示给数组的第一个元素赋值为 5。】
- `-f`：显示所有自定义函数，包括名称和函数体。【注：？】
- `-x`：将变量设置成环境变量，这样在随后的脚本和程序中可以使用。

`variable` 表示变量名称。

**注意：`declare` 命令又写做 `typeset`。**

```bash
# Shell 将所有的数据都看做是字符串来存储
$ x=6/3
$ echo "$x"
6/3
$ declare -i x
# 虽然声明了变量类型，但并不影响其原来的值。
$ echo "$x"
6/3
# 重新赋值，当变量被声明为整型之后，可以直接参与算术运算。
$ x=6/3
$ echo "$x"
2

# 在 Shell 中，如果变量被声明成整型，把一个结果不是整数的表达式赋值给它时，就会变成 0。
$ x="Hello, world!"
$ echo "$x"
0
# bash 不支持浮点数
$ x=3.14
bash: 3.14: syntax error: invalid arithmetic operator (error token is ".14")

# 取消变量的整型属性
$ declare +i x
$ x=6/3
$ echo "$x"
6/3
# 在 Shell 中，为了得到算术式的值，可以有两种方法：一种是使用方括号，另一种是使用圆括号。
$ x=$[6/3]
$ echo "$x"
2
$ x=$((6/3))
$ echo "$x"
2

# 声明变量的只读属性
$ declare -r x
$ echo "$x"
2
$ x=5
bash: x: readonly variable
$ echo "$x"
2
```

### 3.1.5 变量和引号

Shell 语言中一共有 3 种引号，分别为单引号、双引号和反引号。这 3 种引号的作用是不同的，其中单引号括起来的字符都作为普通字符出现【注：转义字符失效】；由双引号括起来的字符，除“$”、“\”、“'”和“"”这几个字符仍是特殊字符并保留其特殊功能外【注：转义字符仍有效】，其余字符仍作为普通字符对待；由反引号括起来的字串被 Shell 解释为命令，在执行时，Shell 首先执行该命令，并以它的标准输出结果取代整个反引号（包括两个反引号）部分。

```bash
#!/usr/bin/env bash

# 输出当前工作目录
echo "CWD: `pwd`"
```

输出结果：
```
CWD: /home/ubuntu/workspace
```

复习到这

### 3.1.6 变量的作用域

**1. 全局变量**

在 Shell 语言中，全局变量可以在脚本中定义，也可以在某个函数中定义。在脚本中定义的变量都是全局变量，其作用域为从被定义的地方开始，一直到 Shell 脚本结束或者被显式地删除。

```bash
#!/usr/bin/env bash

foo() {
    # 在函数内部输出全局变量
    echo $a
    # 在函数内部修改全局变量
    a=200
}

# 在脚本中定义全局变量
a=100

foo

# 在脚本中输出全局变量
echo $a
```

输出结果：
```bash
100
200
```

除了在脚本中定义全局变量之外，**在函数内部定义的变量默认情况下也是全局变量**，其作用域为从函数被调用时执行变量定义的地方开始，一直到 Shell 脚本结束或者被显式地删除为止。
```bash
#!/usr/bin/env bash

foo() {
    # 在函数内定义全局变量
    a=200
}

# 函数内的全局变量在函数被调用时定义
foo

# 在脚本中输出函数内定义的全局变量
echo $a
```

输出结果：
```bash
200
```

**2. 局部变量**

与全局变量相比，局部变量的使用范围较小，通常仅限于某个程序段访问，例如函数内部。在 Shell 语言中，可以在函数内部通过 `local` 关键字定义局部变量，另外，**函数的参数也是局部变量**。

```bash
#!/usr/bin/env bash

foo() {
    # 在函数内定义局部变量
    local a=200
}

foo

# 在脚本中无法访问函数内的局部变量
echo "a = ${a}"
```

输出结果：
```bash
a = 
```

如果用户在函数外面定义了一个全局变量，同时在某个函数内部又存在相同名称的局部变量，则在调用该函数时，函数内部的局部变量会覆盖函数外部定义的全局变量。
```bash
#!/usr/bin/env bash

foo() {
    # 访问全局变量
    echo "Global variable a (foo): ${a}"
    # 定义同名局部变量
    local a=200
    # 覆盖同名全局变量
    echo "Local variable a: ${a}"
}

a=100

foo

echo "Global variable a: ${a}"
```

输出结果：
```bash
Global variable a (foo): 100
Local variable a: 200
Global variable a: 100
```

**注意：Shell 变量中的符号“$”表示取变量的值。只有在取值的时候才使用，定义和赋值时无需使用。另外，实际上 Shell 中变量的原型为 `${var}`，而常用的书写形式 `$var` 只是一个简写。在某些情况下，简写形式会导致程序执行错误。**

### 3.1.7 系统变量

**Shell 中常用的系统变量**
变量 | 说明
---|---
`$n` | `n` 是一个整数，从 1 开始，表示参数的位置，例如 `$1` 表示第 1 个参数，`$2` 表示第 `2` 个参数等。`n` 只能是 1~9 的数字。
`$#` | 命令行参数的个数
`$0` | 当前 Shell 脚本的名称
`$?` | 前一个命令或者函数的返回状态码
`$*` | 以 `"参数1 参数2..."` 的形式将所有的参数通过**一个字符串**返回
`$@` | 以 `"参数1" "参数2"...` 的形式返回**每个参数**
$$ | 返回本程序的进程 ID（PID）


```bash
#!/usr/bin/env bash

# 反斜杠 \ 是转义字符
echo "\$# = ${#}"
echo "\$? = ${?}"
echo "\$0 = ${0}"
echo "\$* = ${*}"
echo "\$@ = ${@}"
echo "\$1 = ${1}, \$2 = ${2}, \$3 = ${3}"
```

输出结果：
```bash
$ ./example.sh one two three
$# = 3
$? = 0
$0 = ./example.sh
$* = one two three
$@ = one two three
$1 = one, $2 = two, $3 = three
```

### 3.1.8 环境变量

**常用的 Shell 环境变量**

变量 | 说明
---|---
`PATH` | 命令搜索路径，以冒号为分隔符。
`HOME` | 用户主目录的路径名
`COLUMNS` | 定义了命令编辑模式下可使用命令行的长度
`HISTFILE` | 命令历史文件
`HISTSIZE` | 命令历史文件中最多可包含的命令条数
`HISTFILESIZE` | 命令历史文件中包含的最大行数
`IFS` | 定义 Shell 使用的分隔符
`LOGNAME` | 当前的登录名
`SHELL` | Shell 的全路径名
`TERM` | 终端类型
`TMOUT` | Shell 自动退出的时间，单位为秒，若设为 0 则禁止 Shell 自动退出。
`PWD` | 当前工作目录

用户可以使用 `set` 命令列出所有的环境变量
```bash
$ set | more
```